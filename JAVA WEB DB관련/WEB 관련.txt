HTTP 
	(Hypertext Transfer Protocol) HTTP는 서버와 클라이언트가 인터넷상에서 데이터를 주고받기 위한 프로토콜(protocol)

URL
	인터넷 상의 자원의 위치
	특정 웹 서버의 특정 파일에 접근하기 위한 경로 혹은 주소

	서버에서 전송한 데이터(HTML과 같은)가 클라이언트에 도착해야 할 곳은 'Browser'입니다.
	Browser에는 데이터를 해석해주는 파서와 데이터를 화면에 표현해주는 렌더링엔진이 포함되어 있습니다.

servlet
	WAS에서 동작하는 java클래스
	HttpServlet 클래스 상속받아야됨
	자바 웹 어플리케이션의 구성요소 중 동적인 처리를 하는 프로그램
	URL요청을 처리하는 프로그램이라 생각해도됨
	http://localhost:8080/{프로젝트이름}/{URL Mapping값}  ex) http://localhost:8080/firstweb/HelloServlet
	
	was는 서블릿 요청을 받으면 해당 서블릿이 메모리에 있는 지 확인 하고
	없으면 해당 서블릿을 메모리에 올리고 init실행 하고  service실행하고 was종료나 서블릿이 새롭게 갱신되었으면 destroy실행
	메모리에 올린후 그 중간에 변화나 종료없이 서블릿이 실행되면 service메소드만 호출됨

	HttpServlet에 service메소드는 템프릿 메소드 패턴으로 구현되어있음
	service를 오버라이드 안하면 부모(HttpServlet)의 service호출함
	부모의 서비스메소드는 내부적으로 어떻게 구현되어있냐면
	클라이언트의 요청이 GET이면 doGet호출
			  Post경우 doPost호출함
	url로 접속하거나 링크 클릭은 get방식으로 서버에 요청임

	parameter에서는 http://~#@~#~@#~@#/?name=kim&age=5
	?를 기점으로 &를 기준으로 파라미터 받아옴

WAS는 웹 브라우저로부터 JSP에 대한 요청을 받게 되면, JSP코드를 서블릿 소스코드로 변환한 후 컴파일 하여 실행

JSP는 JSP가 실행되는게 아니라 소스가 서블릿으로 변환되는거임. 톰캣이 JSP를 서블릿으로 바꿔줌
JSP 실행순서
	브라우저가 웹서버에 JSP에 대한 요청 정보를 전달
	브라우저가 요청한 JSP가 최초로 요청했을 경우만 JSP엔진이 (존재한다면 서블릿 엔진이 받아서 실행)
		JSP로 작성된 코드가 서블릿 코드로 변환한다 (java파일생성, 일단적으로 service메소드에 들어감)
		서블릿 코드를 컴파일해서 실행가능한 bytecode로 변환 (class파일 생성)
		서블릿 클래스를 로딩하고 인스턴스를 생성
	서블릿이 실행되어 요청을 처리하고 응답 정보를 생성

JSP 문법
	선언문  <%! 문장 %>  전역변수 선언 및 메소드 선언
		JSP 페이지 내에서 필요한 멤버변수나 메소드
		service메소드 내부가 아니라 클래스 바디쪽에 생성됨
	스크립트릿 <% %> 프로그래밍 코드 기술 (  ex) java 언어 작성 )
		service 메소드 내부에 생성됨
		지역번수임
		스크립트릿에서 출력할 부분은 내장객체인 out객체의 print() 또는 printfln()사용
	표현식  <%=%> 화면에 출력할 내용

JSP 내장 객체
	대부분의 코드는 생성되는 서블릿 소스의 jspService 메소드 안에 삽입되는 코드가 된다
	service의 윗 부분에 미리 선언된 객체들이 있는데 해당 객체들은 jsp에서도 사용 가능
	response, request application session out 과 같은 변수들을 내장 객체라 한다.
	jsp파일내에서 그냥 사용 가능

4가지 Scope
	Application : 웹 어플리케이션이 시작되고 종료될 때까지 변수가 유지되는 경우 사용, 어플리케이션이 소멸될때까지
	Session : 웹 브라우저 별로 변수가 관리되는 경우 사용, 세션이 소멸될때까지, 요청이 여러개 들어와도 남아있음, 상태유지할때사용하는게 세션스코프
	Request : http요청을 WAS가 받아서 웹 브라우저에게 응답할 때까지 변수가 유지되는 경우 사용, 하나의 요청이 들어와서 응답이 나갈때까지
	Page : 페이지 내에서 지역변수처럼 사용

Page scope
	PageContext 추상 클래스 사용함 ( 해당 클래스는 JSP에서 내장 객체임)
	포워드가 될 경우 page 스코프에 지정된 변수 사용 불가
Requst scope
	http요청을 WAS가 받아서 웹 브라우저에게 응답할 때 까지 변수값을 유지하고자 할 경우 사용
	HttpServletRequest 객체 사용, JSP에서는 내장객체임
	포워드 할 때 값 유지하고자 사용
	응답이 나갈 때 해당 객체들 다 없어짐
Session scope
	웹 브라우저 별로 변수를 관리하고자 할 경우 사용
	탭끼리도 세션정보 공유가능
	클라이언트 별로 세션정도 각각 갖고잇음
	HttpSession 인터페이스 구현한 객체 사용
	JSP에서는 session 내장 변수 사용
	HttpServletRequest의 getSession메소드를 이용하여 세션얻음 누구의 세션인지 알아야되니까 리퀘스트를 통해 세션객체얻어와서 확인
	장바구니 처럼 사용자별로 유지가 되어야할 정보가 있을 때 사용, 클라이언트마다 유지해야될정보가있을 때사용
Application scope
	firstweb 이 프로젝트 하나가 web application 이라 생각하면됨, 그 프로젝트 하나에 딱 하나의 객체를 사용해서 정보들 저장
	웹 어플리케이션 하나당 하나의 어플리케이션 객체 사용 됨
	모든 클라이언트가 공통으로 사용해야할 값들이 있을 때 사용 
	ServletContext인터페이스를 구현한 객체 사용
	jsp는 application 내장 객체 사용
	서블릿은 getServletContext메소드 사용하여 객체 이용

표현언어
	expression language, 값을 표현하는 데 사용되는 스크립트 언어, JSP보완하는 역할
	기본 표현 방법  ${ expr }
	기본 객체들이 여러가지 있음

JSTL
	JSP Standard Tag Library  JSP + HTML 보기어려우니까 보완해주는느낌
	JSTL을 이용하면 태그형식으로 "조건문, 반복문 등"을 사용할 수 있습니다.
	그리고, 앞에서 배운 EL과 연동하면 더욱 강력하게 사용 가능합니다. 
	객체에 property가 나오면 이 객체의 값을 변경하거나 읽어들이는 게터세터 생각하면됨
	import는 특정 url에 연결하여 결과를 지정한 변수에 저장
	리다이렉트는 response.sendRedirect() 와 비슷

컨테이너
	인스턴스를 직접 생성하고 소멸하는 작업을 우리가직접하지 않고 해주는거임
	서블릿 컨테이너가 이것저것 해주는것처럼..
	
IoC
	(Inversion of Control)  제어의 역전
	다른 프로그램이 흐름을 제어하는 것

DI
	(Dependency Injection) 클래스 사이의 의존관계를 Bean 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것
	내가원하는 객체를 내가만드는게 아니라 spring 에서 제공하는 공장이 만들어서 주입시키는거임
	공장이 자동으로 만들어주는 객체를 bean이라함

	context가 공장임

의존성 주입을 java config를 이용하여도 할 수 잇음 xml에 bean등록 말고. 어노테이션과 자바컨피스파일을 이용해서도 가능

spring JDBC
	우리가 당연히 제공해줘야될 정보만 제공해주면  spring framework가 알아서 해준다

JDBC Template
	리소스 생성, 해지를 처리해서 연결을 닫는 것을 잊어 발생하는 문제 등을 피할 수 있도록 합니다

DTO
	DTO란 Data Transfer Object의 약자
	계층간 데이터 교환을 위한 자바빈즈입니다.
	여기서의 계층이란 컨트롤러 뷰, 비지니스 계층, 퍼시스턴스 계층을 의미합니다.
	일반적으로 DTO는 로직을 가지고 있지 않고, 순수한 데이터 객체입니다.
	필드와 getter, setter를 가진다. 추가적으로 toString(), equals(), hashCode()등의 Object 메소드를 오버라이딩 할 수 있습니다.

DAO
	DAO란 Data Access Object의 약자로 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체입니다.
	보통 데이터베이스를 조작하는 기능을 전담하는 목적으로 만들어집니다.
	
ConnectionPool
	DB연결은 비용이 많이 듭니다.
	커넥션 풀은 미리 커넥션을 여러 개 맺어 둡니다.
	커넥션이 필요하면 커넥션 풀에게 빌려서 사용한 후 반납합니다.


applicationContext
	spring이 제공해주는 class, 얘한테 어떤어떤 설정들을 읽어서 공장을 만들어줘요할건데 그부분이 ApplicationConfig 임
ApplicationConfig


MVC
	MVC는 Model-View-Controller의 약자입니다
	Model : 모델은 뷰가 렌더링하는데 필요한 데이터입니다. 예를 들어 사용자가 요청한 상품 목록이나, 주문 내역이 이에 해당합니다.
	View : 웹 애플리케이션에서 뷰(View)는 실제로 보이는 부분이며, 모델을 사용해 렌더링을 합니다. 뷰는 JSP, JSF, PDF, XML등으로 결과를 표현합니다.
	Controller : 컨트롤러는 사용자의 액션에 응답하는 컴포넌트입니다. 컨트롤러는 모델을 업데이트하고, 다른 액션을 수행합니다.

	서블릿이 요청자체를 받고 서블릿이 java bean을 이용해서 db에서 데이터를 꺼내오고
	이런 결과들을 jsp를 통해서 결과를 화면에 보여주게함
	서블릿이 요청과 데이터를 처리하는 컨트롤러의 역할
	jsp는 모델의 결과를 보여주게하는 뷰의역할

	위를 좀더 발전시키면 아래와같음
	클라이언트가 보내는 모든 요청을 프론터 컨트롤러라고 하는 서블릿클래스가 다 받음, 이 서블릿 클래스는 딱 하나만 존재.
	프론트 컨트롤러는 요청만 받고 실제 일은 처리하지않음, 일은 컨트롤러 클래스(핸들러 클래스)에게 위임함
	서블릿은 관련된 요청을 처리하기에 불편한 구조를 갖고있어서 이런 단점을 해결하기 위해 사용자의 모든요청을 서블릿이 받고, 그 요청의 실제처리는
	컨트롤러(핸들러) 클래스에게 위임해서 관련된 url을 하나의 클래스에서 다 처리
	이런 컨트롤러는 java bean등을 이용해서 결과를 만들어내고 만들어진 결과를 모델에 담고 프론트 컨트롤러에게 보내고
	프론트 컨트롤러는 알맞은 뷰에게 모델을 전달해서 그 결과를 출력함
	이제 spring프래임워크 모듈중 하나인 web모듈에 구현되어있음 이러한 web모듈을 spring MVC라고한다

	모든 요청을 dispatcher servlet클래스가 받음 얘는요청을 처리해줄 컨트롤러와 메서드가 무엇인지 핸들러 매핑에게 물어봄
	핸들러 매핑이 다 알아낼순없으므로 개발할때 spring mvc로 개발하면 xml이나 java파일에 어노테이션으로 어떤요청에 어떤 컨트롤러가 동작할지 설정해놓음
	이런 정보들을 spring으로 만들어진 웹 애플림케이션이 실행할때 핸들러 매핑 객체들이 생성되면서 관리를 하게됨
	Dispatcher Servlet은 그렇게 핸들러 맵핑으로부터 지금 요청에 알맞은 컨트롤러가 무엇인지 해당되는 메서드는 무엇인지에 대한 정보를 알아냄
	알아냈으면 핸들러 아답트에게 요청하고 이때 결정된 컨트롤러와 해당 메서드가 실행이될거고
	그 결과를 model에 받아서 dispatcher servlet에게 전달
 	이때 dispatcher servlet은 컨트롤러가 리턴한 view name을 알아오게 될거고, 컨트롤러가 리턴한 뷰네임을 가지고 적절한 뷰 resolver를 통해서 뷰를 출력함
	뷰resolver가 어떤 뷰다라는 정보를 정확하게 알려주게되면 이 뷰로 응답을 하게될것임
	Spring MVC를 이해한다는 것은 DispatcherServlet이 어떻게 동작하는지를 이해하는 것

DispatcherServlet  
	프론트 컨트롤러 (Front Controller)
	클라이언트의 모든 요청을 받은 후 이를 처리할 핸들러에게 넘기고 핸들러가 처리한 결과를 받아 사용자에게 응답 결과를 보여준다.
	DispathcerServlet은 여러 컴포넌트를 이용해 작업을 처리한다.

Controller
	URL은 다르지만 URL에 해당하는 웹페이지를 보여주기 위해서 실행되는 부분 중에 중복이 되는 부분이 있다면 어떻게 해야 될까요?
		별도로 객체 분리 or 중복된 부분을 별도의 메서드로 처리 
		회원 정보를 읽어들이는 것만 별도의 객체로 만들고 해당 컨트롤러들은 이 객체를 이용하면 되겠죠
	이런 컨트롤러들이 중복적으로 호출되는 부분들. 이런 것들을 별도의 객체인 "서비스"로 구현을 하게 됩니다.
	서비스 객체는 보통 업무와 관련된 메서드를 가지고 있는데요. 이것들을 비즈니스 메서드 라고 얘기를 합니다.
		컨트롤러 1이나 3에 각각 구현하는 것이 아니라 상품에 관련된 비즈니스만 처리하는 이런 서비스 객체를 따로 만들어놓고 컨트롤러 1도 사용하고 컨트롤러 3도 사용하게 하면 더 효율적
위에서 말하는 서비스 객체
	비즈니스 로직을 수행하는 메서드를 가지고 있는 객체
	하나의 비즈니스 로직은 하나의 트랙잭션으로 동작
		트랜잭션
			원자성 ( 아예성공 or 아예실패 )   수행하다 실패하면 복원시켜야되는 데 이걸 rollback이라함 끝까지 다 성공해야만 성공한 것을 반영하는 것임 이를 commit이라한다 
				롤백하거나 커밋하면 하나의 트랙잭션처리가 완료됐다함
			일관성 트랜잭션이 진행되는 동안에 데이터가 변경되더라도 업데이트된 데이터로 진행되는것이 아니라 처음에 트랜잭션 진행하기 위해 참조한 데이터로 진행함
			독립성 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 경우에 어느 하나의 트랜잭션이라도 다른 트랜잭션의 연산을 끼어들 수 없다. 하나의 특정 트랜잭션이 완료될 때까지 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.
			지속성  트랜잭션이 성공적으로 완료됐을 때 결과가 영구적으로 반영이 돼야겠죠. 이런 트랜잭션 처리를 JDBC 프로그래밍에서 사용할 때에는요. JDBC에서 Connection 객체 얻어냈었잖아요? 이 Connection 객체를 대부분 Connection con 이렇게 얻어냈었는데 con.setAutoCommit() 이런 메서드를 수행할 수가 있어요. 이 메서드의 실제, AutoCommit의 디폴트는 true로 되어있거든요 우리가 별도로 commit 같은 명령을 수행하지 않아도 바로 데이터베이스에 반영
				지금처럼 여러 개의 작업이 끝나야지, 그 작업들이 모두 성공했어야지만 나는 commit을 반영하겠다고 한다면 해당 메서드에 false라고 파라미터를 지정하신 다음에 일들을 다 수행하고 조건이 만족했을 때만 commit()이라는 메서드를 수행하게끔 여러분이 코드를 만들어주시면 JDBC에서도 이렇게 트랜잭션을 처리하실 수 있으실 거예요.
		Spring에서는 이런 트랜잭션을 처리하기 위해서 자바 Config 파일에다가 @EnableTransactionManagement라는 어노테이션을 이용해가지고 수행
	Presentation Layer, 지금 이 부분에서는 컨트롤러 객체가 동작을 하게 하는 거고요
	Service Layer에서는 비즈니스 메서드를 가지고 있는 서비스 객체가 동작하게 하면 되고, Service 객체는 해당 Repository Layer에 있는 DAO 객체를 사용하게 될 거예요.
	Repository Layer(DAO) 실제 데이터베이스에 접근해서 데이터를 가져온다든지 이런 일들만 수행

Rest API를 작성하기 위해서 Spring MVC는 @RestController를 제공해요.
참고로 Spring 3에서는 @Controller와 @ResponseBody를 사용해서 썼었고요.
4에서는 Rest API 또는 Web API를 개발하기 위해서 @RestController이 추가가 되었어요.
	이전 버전에서 사용했었던 @Controller, @ResponseBody도 포함을 하고 있고요.
RestController를 사용하기 위해서는 MessageConvertor가 굉장히 중요한데요
	예를 들면 외부에서 전달받은 JSON 메서드를 내부에서 사용할 수 있는 객체로 변환하거나
	컨트롤러를 리턴 한 객체가 클라이언트에게 JSON으로 변환해서 전달할 수 있도록 하는 역할을 하는 것이 MessageConvertor가 수행을 해줘요.
	이런 MessageConvertor를 @EnableWebMvc로 사용하게 되면 기본으로 제공이 됩니다.
	그런데 문제는 json으로 변환을 하기 위해서 기본 MessageConvertor는 jackson 라이브러리를 사용하고 있거든요
	그래서 만약에 jackson 라이브러리가 제대로 추가해야됨 안하면 500번 오류발생함
	